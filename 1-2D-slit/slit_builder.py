import numpy as np
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning) 
from scipy.spatial.transform import Rotation
import argparse
from pathlib import Path

def fold_y(structure_in, axis_pos, rotation):
    '''
    Fold structure along a y-axis
    args:
        structure (nd.array): input structure (n_atoms, 3)
        axis_pos (tuple): position of axis
        rotation (float): fold rotation in degree
    '''
    structure = structure_in.copy()
    axis_pos = np.array(axis_pos)
    x_fold, y_fold, _ = axis_pos
    select = structure[:,0]>x_fold
    
    sub_structure =  structure[select] - axis_pos
    rot = Rotation.from_euler('y', rotation, degrees=True)
    sub_structure = np.dot(sub_structure,rot.as_matrix()) + axis_pos
    structure[select] = sub_structure
    return structure

def build_slit(H:float, Hc: float,
               Lc: float,
               p:float,
               d=1.42):
    '''
            ┃   ┃     ↑  
            ┃   ┃     │
            ┗━━━┛     │
                 ↕ Hc │ 2 H
            ┏━━━┓     │
            ┃   ┃     │
            ┃   ┃     ↓
             ←-→        
             Lc
    ↑x
    │
     --->z
    '''
    
    
    # Dimension of graphene sheets to generate
    GRA_L_x = 2*H-Hc+Lc
    GRA_L_y = p
    
    # Define Graphene unit cell
    angle = np.pi/3
    uc_x = 2*d*np.sin(angle)
    uc_y = d*np.cos(angle) + d + d*np.cos(angle) + d

    v1 = d*np.array([0, -1, 0])
    v2 = d*np.array([np.cos(angle/2), np.sin(angle/2), 0])
    v3 = d*np.array([-np.cos(angle/2), np.sin(angle/2), 0])

    C0 = np.array([0, 0, 0])
    C1 = C0+v3
    C2 = C1-v1
    C3 = C2+v2
    uc = np.vstack((C0, C1, C2, C3))

    # Create layer from unit cell
    N_x, N_y = round(GRA_L_x/uc_x), round(GRA_L_y/uc_y)
    # Adjust graphene sheets to generate as a multiple size of UC
    GRA_L_x, GRA_L_y = uc_x*N_x, uc_y*N_y
    
    gx_3D, gy_3D, gz_3D = np.meshgrid(
      uc_x*np.arange(N_x), uc_y*np.arange(N_y), 0.)
    gx_1D, gy_1D, gz_1D = gx_3D.flatten(), gy_3D.flatten(), gz_3D.flatten()
    
    gxyz_1D = np.vstack((gx_1D, gy_1D, gz_1D))
    
    graphene_sheet = uc[:, :, np.newaxis]+gxyz_1D[np.newaxis, :, :]
    graphene_sheet = np.reshape(np.rollaxis(graphene_sheet, 2), 
                                (N_x*N_y*4, 3,), order='C')
    graphene_sheet-=graphene_sheet.min(axis=0)
    
    # Folding part
    # Adjust channel length as a multiple of unit cell size 
    Lc = uc_x*round(Lc/uc_x)
    
    structure1 = graphene_sheet.copy()
    structure1-= np.array([(GRA_L_x-Lc)/2,0,0])
    structure1 = fold_y(structure1, (Lc,0,0), 90)
    structure1 = fold_y(structure1, (0,0,0), 90)
    structure1-= np.array([Hc/2,0,Lc/2])

    structure2 = structure1.copy()
    structure2[:,0]*=-1
    structure2[:,2]*=-1
    structure=np.vstack((structure1, structure2))
    
    # Box dimension
    lx = (GRA_L_x-Lc)+Hc
    ly = p
    lz = Lc
    
    # Recenter structure
    structure += np.array([0, -ly, -lz])/2
    
    Natoms = structure.shape[0]



    return structure, (lx, ly, lz) 

if __name__=='__main__':
    parser = argparse.ArgumentParser(description=
 """
            ┃   ┃     ↑     \n
            ┃   ┃     │     \n
            ┗━━━┛     │     \n
                 ↕ Hc │ 2 H \n
            ┏━━━┓     │     \n
            ┃   ┃     │     \n
            ┃   ┃     ↓     \n
             ←-→            \n
             Lc             \n
    ↑x                      \n
    │                       \n
     --->z                  \n
 """
                                    )
    parser.add_argument("outputFilePath", type=str)
    parser.add_argument("-H", type=float)
    parser.add_argument("-Hc", type=float)
    parser.add_argument("-Lc", type=float)
    parser.add_argument("-ly", type=float)
    parser.add_argument("-d", type=float, default=1.42)
    args = parser.parse_args()
    outputFilePath = Path(args.outputFilePath)

    structure, (lx, ly, lz) = build_slit(H=args.H,
                                         Hc=args.Hc,
                                         Lc=args.Lc,
                                         p=args.ly,
                                         d=args.d)
    with outputFilePath.open('w') as f:
            f.write("Lammps data file generated by slit_builder\n")
            f.write("\n")

            f.write(f"{structure.shape[0]} atoms\n")

            f.write(f"1 atom types\n")
            f.write("\n")

            xlo, ylo, zlo = -lx/2, -ly/2, -lz
            xhi, yhi, zhi = +lx/2, +ly/2, 0
            f.write(f"{xlo:.6f} {xhi:.6f} xlo xhi\n")
            f.write(f"{ylo:.6f} {yhi:.6f} ylo yhi\n")
            f.write(f"{zlo:.6f} {zhi:.6f} zlo zhi\n")
            f.write("\n")

            f.write("Atoms\n\n")

            i=1
            for (x,y,z) in structure:
                if z<zlo+1E-4: # Bottom
                    f.write(f"  {i} 1 3 0 {x:.8f} {y:.8f} {z:.8f}\n")
                elif z>zhi-1E-4: # Top
                    f.write(f"  {i} 1 2 0 {x:.8f} {y:.8f} {z:.8f}\n")
                else: # Channel
                    f.write(f"  {i} 1 1 0 {x:.8f} {y:.8f} {z:.8f}\n")
                i += 1

    with outputFilePath.with_suffix('.lmps').open('w') as f:
        f.write(f'variable slit_lx equal {lx}\n')
        f.write(f'variable slit_ly equal {ly}\n')
        f.write(f'variable slit_H equal {lx/2}\n')
        f.write(f'variable slit_Hc equal {args.Hc}\n')
        f.write(f'variable slit_Lc equal {lz}\n')
        f.write(f'variable slit_d equal {args.d}\n')
        
    
    