log             init.log # Separate log files
## Variable definition
    
    variable        SEED equal 1991 # The seed for sampling initial water and salt position

    variable        C_ions equal 1 # [mol/L] Ion concentation
    variable        input_sigma_top equal -100 # [mC/m²] The surface chard carried by the top layer
    variable        input_sigma_bot equal 0 # [mC/m²] The surface chard carried by the bottom layer

    variable        efieldz equal 0.1 # [V/A] The external field to applied along z
    variable        DeltaP equal 0 # [MPa] The pressure difference to applied through the system
    variable        Text equal 300.0 # [K] The temperature of the thermostat

    variable        Nsteps equal 2500000 # The number os steps (x2 fs = 50 ps)

    variable        freqDump equal 100 # The frequency of the output


    # timer           timeout 23:30:00 every 100 # if necessary, set a timeout value. Usefull when woring on Clusters

## Define some general LAMMPS parameters
    units           real # distance : A, time : fs, energy: Kcal/mole, masse: grams/mole
    atom_style      full # atom-ID molecule-ID atom-type q x y z
    boundary        p p p # Periodic box
    newton          off # Not really important but allow to compute simulation on GPUs

## Geometry setting
    #
    #  ┃   ┃     ↑
    #  ┃   ┃     │  
    #  ┗━━━┛     │
    #       ↕ Hc │ 2 H
    #  ┏━━━┓     │
    #  ┃   ┃     │
    #  ┃   ┃     ↓
    #   ←-→ ←-----------------→   
    #   Lc          L
    #
    # ↑x
    # │
    #  --->z

    variable        input_L  equal 100 # [A] Reservoir's depth
    variable        input_H equal 50 # [A] Reservoir's half height
    variable        input_Hc equal 30 # [A] Channel height
    variable        input_Lc equal 100 # [A] Channel length
    variable        input_ly equal 100 # [A] Width of the simulation box

    # Use python script to create the pore geometry
    variable        input_d equal 1.42 # A C-C distance in graphene
    shell           python slit_builder.py slit.data -H ${input_H} -Hc ${input_Hc} -Lc ${input_Lc} -ly ${input_ly} -d ${input_d}
    include         slit.lmps # include variable slit_lx, slit_Lc ... generated by the python file

    # Define simulation box
    region          box block $(-v_slit_lx/2) $(v_slit_lx/2) & 
                              $(-v_slit_ly/2) $(v_slit_ly/2) &
                              0 ${input_L} &
                              units box
    create_box      7 box                       &
                    bond/types 1                &
                    angle/types 1               &
                    extra/bond/per/atom 2       &
                    extra/angle/per/atom 1      &
                    extra/special/per/atom 2 # Create simulation box
    
    # Add the slit
    read_data       slit.data add append &
                    offset 2 1 1 1 1 # Let type 1 and 2 for H and O
    #Define groups
    group           gC type 3 4 5
    group           gC_bot type 5
    group           gC_top type 4


## Define accessible region and compute its volume
    #
    #  ┃   ┃ 11111111111111111
    #  ┃   ┃ 11111111111111111
    #  ┗━━━┛ 11111111111111111
    #   2222211111111111111111
    #  ┏━━━┓ 11111111111111111
    #  ┃   ┃ 11111111111111111
    #  ┃   ┃ 11111111111111111
    #   ←-→ ←-----------------→   
    #   Lc          L
    #   1 : r_channel
    #   2 : r_reservoir
    # ↑x
    # │
    #  --->z

    variable        s  equal 2 # [A] skin to add at boundary limit and around walls. Need to ass this safe distance at boundary limit to avoid deformation of water molecules (a bug here ?)

    # 1. Reservoir
    region          r_reservoir block $(-lx/2+v_s) $(lx/2-v_s) $(-ly/2+v_s) $(ly/2-v_s) $(v_s) $(v_input_L-v_s) units box
    variable        V_reservoir equal lx*ly*v_input_L # A^3

    # 2. Channel space
    region          r_channel block $(-v_slit_Hc/2+v_s) $(v_slit_Hc/2-v_s) $(-ly/2+v_s) $(ly/2-v_s) $(-v_slit_Lc+v_s) $(v_s) units box 
    variable        V_channel equal v_slit_Hc*ly*v_slit_Lc
    
    # Total
    region          r_filling union 2 r_reservoir r_channel
    variable        V_accessible equal v_V_reservoir+v_V_channel
    
## Fill accessible region with water molecules
    variable        V_SOL index 29.9 # A^3 : volume of water molecule
    variable        N_SOL equal round(v_V_accessible/v_V_SOL/1.043) # Dividing by this *empirical* factor allow to have the right density in bulk
    print           "${N_SOL} water molecules will be added"

    # Define the lattice on which molecules will be added
    variable        spacing index 3.0 # Lattice spacing used to add water molecules
    lattice 	    hcp ${spacing} # hcp lattice
    
    molecule        h2omol spce.mol # Read SPCE water molecule
    #Populate hcp lattice with water molecules
    create_atoms   	0 region r_filling mol h2omol ${SEED} subset ${N_SOL} ${SEED} units box
    lattice         none 1.0 # Remove lattice now it was used
    
    #Define groups
    group           gH type 1
    group           gO type 2
    group           gSOL type 1 2

## Convert surface charge density to a charge to assign to carbon atoms
    variable        surface_bot_top_area equal (lx-v_slit_Hc)*ly # Surface area of membrane
    variable        real_surface_charge equal 1E-3*1E-20/1.6E-19 # [mC/m²] -> [e/A^2]

    #Corrects the value of the surface charge so that it can be compensated by the charge of the ions
    variable        surface_bot_charge equal $(round(v_surface_bot_top_area*v_input_sigma_bot*v_real_surface_charge)) # [e] Total surface charge of the bottom layer
    variable        surface_top_charge equal $(round(v_surface_bot_top_area*v_input_sigma_top*v_real_surface_charge)) # [e] Total surface charge of the top layer

    variable        sigma_bot equal $(v_surface_bot_charge/v_surface_bot_top_area) # [e/A^2] 
    variable        sigma_top equal $(v_surface_top_charge/v_surface_bot_top_area) # [e/A^2]
    print           "The bottom surface charge will be corrected : ${input_sigma_bot} -> $(v_sigma_bot/v_real_surface_charge) mC/m^2"
    print           "The top surface charge will be corrected : ${input_sigma_top} -> $(v_sigma_top/v_real_surface_charge) mC/m^2"

    
    variable        N_C_bot equal count(gC_bot)
    variable        charge_C_bot equal $(v_sigma_bot/v_N_C_bot) # [e] Charge to add to carbons of the bottom layer
    
    variable        N_C_top equal count(gC_top)
    variable        charge_C_bot equal $(v_sigma_top/v_N_C_top) # [e] Charge to add to carbons of the top layer

## Fill accessible region with ions
    if "${C_ions} == 0" then "jump SELF skip_ions"
    
    variable        MOL_to_A3 index 0.000602214076 # convert mol/L to 1/A^3 (N_A*1E3*1E-30)
    variable        N_ions_n equal round(v_V_accessible*v_C_ions*v_MOL_to_A3)
    print           "${N_ions_n} negative ion will be added"

    variable        N_ions_p equal v_N_ions_n-v_surface_bot_charge-v_surface_top_charge # Correct the number of positive charge added in system to keep electroneutrality
    print           "${N_ions_p} positive ion will be added"

    # Populate hcp lattice with ions (shifted compared to the lattice used for water filling)
    lattice 	    hcp ${spacing} origin 0.5 0.5 0.5
    create_atoms    6 region r_filling subset $(v_N_ions_p+v_N_ions_n) $(v_SEED) units box
    set             type 6 type/subset 7 $(v_N_ions_n) $(v_SEED) # This procedure ensures that negative and positive ions are not found on the same lattice nodes

    lattice         none 1.0 # Remove lattice now it was used
    label           skip_ions

## Add forcefield
    # Carefull, we need to include forcefield *after* adding water molecule and ions and *before* changing the charges of the top and bottom layers.
    include         forcefield.ff
    
## Change charge carried by carbon atoms
    set             type 5 charge $(v_surface_bot_charge/v_N_C_bot)
    set             type 4 charge $(v_surface_top_charge/v_N_C_top)
    
    #Define groups
    group           gions_p type 6
    group           gions_n type 7
    group           gions union gions_p gions_n
    group           gions_and_water union gSOL gions

# Write initial configuration
write_data      init.data nocoeff

# set parameters of Verlet neighbor list
neighbor        2.0 bin # Additionnal skin distance added to forcefield cutoff distance
neigh_modify    every 1 delay 10 check yes # Build pair wise list 1 time every 10 timesteps.

# Freeze carbon atoms
fix             freezeC gC setforce 0.0 0.0 0.0

# Write down initial configuration in xyz format
dump            d_xyz all xyz 1 init.xyz
dump_modify     d_xyz element H O C C C Na Cl
run             0 post no
undump          d_xyz

# -----------------------------------------------------------------------
## Minimization step
    log             em.log

    # Get atoms with highest forces (usefull for debugging)
    variable        fnorm atom "sqrt(fx^2+fy^2+fz^2)"
    compute         1 all property/atom id type
    compute         2 all reduce max c_1[1] c_1[2] v_fnorm replace 1 3 replace 2 3

    # Define thermo logging setting
    thermo          1
    thermo_style    custom step evdwl ecoul ebond eangle etotal fmax c_2[1] c_2[2]

    # Minimize total energy
    min_style       cg # conjugate gradient (CG) algorithm for minimization
    minimize        1.0e-5 1.0e-6 1000 2000
    
    # Write configuration after energy minimization
    write_data      em.data nocoeff

    # Write down the configuration in xyz format
    dump            d_xyz all xyz 1 em.xyz
    dump_modify     d_xyz element H O C C C Na Cl
    run             0 post no
    undump          d_xyz

    uncompute       1
    uncompute       2

    label skip_em
    
timestep        2.0 # 1fs timestep
run_style       verlet # velocity-Verlet integrator (=md-vv of GROMACS)

# Apply constraint on SPCE bonds  
# Each timestep the specified bonds and angles are reset to their equilibrium lengths and angular values via the SHAKE algorithm
fix             2 all shake 0.0001 20 0 b 1 a 1 # 0.0001=tolerance, 20=max iteration for solving equation, 0=no log, b 1=on bonds with ID 1, a 1=on angles with ID 1
# -----------------------------------------------------------------------
## Thermalization step
    log             nvt.log
    reset_timestep  0

    # Set ensemble
    fix             3 gions_and_water nvt temp ${Text} ${Text} $(100.0/dt)

    # Compute bulk density
    region          bulk block INF INF INF INF $(v_input_L/2-10) $(v_input_L/2+10) units box
    variable        massconvert index 1.660539 # convert g/mol to g/cm^3
    variable        densitySOL_bulk equal v_massconvert*mass(gSOL,bulk)/(lx*ly*20) # Be carefful to not put any whitespace after the coma in the mass command
    fix             ave_densitySOL_bulk all ave/time 1 1 1 v_densitySOL_bulk ave running

    # Compute ions and water temperature
    compute         Tions_and_water gions_and_water temp
    variable        tempions_and_water equal c_Tions_and_water

    # Define thermo logging setting
    thermo          100 # Log every frame
    thermo_style    custom step c_Tions_and_water lz pzz f_ave_densitySOL_bulk # Logging format

    # Define dumping
    dump            d_xyz all xyz 100 nvt.xyz
    dump_modify     d_xyz element H O C C C Na Cl

    run             1000

    # Write configuration after thermalization minimization
    write_data      nvt.data nocoeff

    undump          d_xyz
    unfix           ave_densitySOL_bulk

    


# -----------------------------------------------------------------------
## Simulation step
    log             sim.log
    reset_timestep  0
    
    # Add electric field
    fix             6 all efield 0.0 0.0 ${efieldz}

    # Add pressure drop
        if "${DeltaP} == 0" then "jump SELF skip_pressure"
        variable        w_DeltaP equal 5 # A - z-width of the region on which to applied the force 

        # Compute number of water molecules inside the region where pressure is applied
        region          region_DeltaP block INF INF INF INF $(v_input_L/2-v_w_DeltaP) $(v_input_L/2+v_w_DeltaP) units box
        variable        V_DeltaP equal 2*lx*ly*v_w_DeltaP
        variable        N_SOL_DeltaP equal round(v_V_DeltaP/v_V_SOL)
        print           "Forces applied on ${N_SOL_DeltaP} water molecules in average"

        # Compute the force to apply on water molecules to target the pressure
        variable        A equal lx*ly # Cross section
        variable        N_A equal 6.0221415e23 # Avogadro's number
        variable        KCal equal 4184 # 1KCal -> Joule
        variable        MPa_to_real equal 1e6*(${N_A}*1e-30)/${KCal} # MPa -> Kcal/mole/A^3
        variable        force_DeltaP equal ${DeltaP}*${MPa_to_real}*$A/${N_SOL_DeltaP} # 
        print           "Force = ${force_DeltaP} Kcal/mole/A"
        
        fix             pressure gO addforce 0.0 0.0 ${force_DeltaP} region region_DeltaP
        label           skip_pressure
    
    # Define thermo logging setting
    thermo          ${freqDump}
    thermo_style    custom step c_Tions_and_water

    # Another equlibiration step 
    run             10000

    # 2D binning part
    compute         chunck2D all chunk/atom bin/2d z lower 1 x lower 1
    fix             chunck2D_ions_p_fcoul gions_p   ave/chunk 1 10 100 chunck2D vx vy vz fx fy fz ave running overwrite file ions_p.profile
    fix             chunck2D_ions_n_fcoul gions_n   ave/chunk 1 10 100 chunck2D vx vy vz fx fy fz ave running overwrite file ions_n.profile
    fix             chunck2D_O_fcoul gO             ave/chunk 1 10 100 chunck2D vx vy vz fx fy fz ave running overwrite file O.profile
    fix             chunck2D_H_fcoul gH             ave/chunk 1 10 100 chunck2D vx vy vz fx fy fz ave running overwrite file H.profile

    # Dumping
    # Define dumping
    dump            d_xyz gions xyz ${freqDump} therm.xyz
    dump_modify     d_xyz element Na Cl

    run             ${Nsteps}
    write_restart   restart
    undump          d_ions

    dump            d_xyz all xyz 1 sim.*.xyz
    dump_modify     d_xyz element H O C C C Na Cl
    run             0 post no